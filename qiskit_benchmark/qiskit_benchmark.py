"""Main module"""

from datetime import datetime, timedelta
from itertools import product
from pathlib import Path
from typing import Any

import matplotlib.pyplot as plt
import pandas as pd
import qiskit
import seaborn as sns
import turbo_broccoli as tb
from joblib import Parallel, delayed
from qiskit import qasm3
from qiskit.circuit.random import random_circuit
from qiskit_aer import AerSimulator
from tqdm import tqdm


def generate_random_circuits(
    output_dir: Path,
    qbits_range: tuple[int, int],
    depth_range: tuple[int, int],
    n_circuits: int,
    n_jobs: int = -1,
) -> None:
    """
    Generating random circuits using
    [`random_circuit`](https://docs.quantum.ibm.com/api/qiskit/circuit#random_circuit)
    is expensive. This method generates a bunch in parallel using
    [`joblib`](https://joblib.readthedocs.io/en/stable/). Creates circuit files
    with path

        <output_dir>/<n_qbits>_<depth>_<n>.qasm3

    Args:
        output_dir (Path):
        qbits_range (tuple[int, int]):
        depth_range (tuple[int, int]):
        n_circuits (int): Number of circuits to generate for each qubit and
            depth, **NOT** the total number of circuits.
    """

    def _filepath(q: int, d: int, n: int) -> Path:
        return output_dir / f"{q}_{d}_{n}.qasm3"

    def _generate(q: int, d: int, n: int) -> None:
        """Generates a single circuit and saves it to a file"""
        circuit = random_circuit(
            num_qubits=q, depth=d, measure=True, conditional=True
        )
        with _filepath(q, d, n).open("w", encoding="utf-8") as fp:
            qasm3.dump(circuit, fp)

    executor = Parallel(n_jobs=n_jobs, verbose=1)
    everything = product(
        range(qbits_range[0], qbits_range[1] + 1),
        range(depth_range[0], depth_range[1] + 1),
        range(1, n_circuits + 1),
    )
    executor(
        delayed(_generate)(q, d, n)
        for q, d, n in everything
        if not _filepath(q, d, n).is_file()
    )


# pylint: disable=too-many-locals
def run(
    output_file: Path,
    circuits_dir: Path,
    qbits_range: tuple[int, int],
    depth_range: tuple[int, int],
    n_shots: int,
    n_circuits: int,
    method: str,
    device: str,
) -> list[dict[str, Any]]:
    """
    Runs the benchmark. Each iteration is guarded.

    Args:
        output_file (Path): Output JSON file path
        circuits_dir (Path): Directory where the circuits `.qasm3` files
            generated by `generate_random_circuits` are stored. For every value
            of `n_qbits`, `depth`, and `n`, there should be a file named
            `<n_qbits>_<depth>_<n>.qasm3` in this directory.
        qbits_range (tuple[int, int]):
        depth_range (tuple[int, int]):
        n_shots (int):
        n_circuits (int):
        method (str):
        device (str):

    Returns:
        `list[dict[str, Any]]`
    """
    everything = list(
        product(
            range(qbits_range[0], qbits_range[1] + 1),
            range(depth_range[0], depth_range[1] + 1),
            range(1, n_circuits + 1),
        )
    )
    progress = tqdm(everything, desc="Benchmarking", total=len(everything))
    guard = tb.GuardedBlockHandler(output_file)
    simulator = AerSimulator(method=method, device=device)
    for _, (n_qbits, depth, n) in guard(progress, result_type="dict"):
        progress.set_postfix({"n_qbits": n_qbits, "depth": depth, "n": n})
        data = {
            "depth": depth,
            "device": device,
            "method": method,
            "n_qbits": n_qbits,
            "n_shots": n_shots,
        }
        start = datetime.now()
        circuit = qasm3.load(circuits_dir / f"{n_qbits}_{depth}_{n}.qasm3")
        data["load_time"] = (datetime.now() - start) / timedelta(seconds=1)
        start = datetime.now()
        circuit = qiskit.transpile(circuit, simulator)
        data["transpile_time"] = (datetime.now() - start) / timedelta(
            seconds=1
        )
        start = datetime.now()
        result = simulator.run(circuit, shots=n_shots).result()
        data["run_time"] = (datetime.now() - start) / timedelta(seconds=1)
        data["result"] = result.to_dict()
        guard.result[(n_qbits, depth, n)] = tb.EmbeddedDict(data)
    return list(guard.result.values())


def make_result_dataframe(results: list[dict[str, Any]]) -> pd.DataFrame:
    """
    Makes a dataframe out of the results provided by `run`. This method is not
    guarded.

    Args:
        output_file (Path): Output CSV file path
        results (list[dict[str, Any]]):

    Returns:
        Pandas dataframe
    """
    df = pd.DataFrame(
        columns=["n_qbits", "depth", "load_time", "transpile_time", "run_time"]
    )
    for r in tqdm(results, desc="Post-processing"):
        df.loc[len(df)] = {k: r[k] for k in df.columns}
    return df


def plot_results(df: pd.DataFrame, output_dir: Path):
    """
    Plots the results. This method is guarded.

    Args:
        df (pd.DataFrame):
        output_dir (Path):
    """

    df = df.groupby(["n_qbits", "depth"]).mean().reset_index()

    def _plot(key: str, title: str, filename: str):
        plot = sns.heatmap(
            df.pivot(index="n_qbits", columns="depth", values=key),
            annot=True,
            fmt=".2f",
        )
        plot.set(title=title)
        plot.get_figure().savefig(output_dir / filename)
        plt.clf()

    _plot("load_time", "QASM3 file loading time (s)", "load_time.png")
    _plot("transpile_time", "Transpile time (s)", "transpile_time.png")
    _plot("run_time", "Execution time (s)", "execution_time.png")
